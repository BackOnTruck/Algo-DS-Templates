### 带花树算法

带花树用于解决一般图匹配问题. 即求出一个最大的边集, 使所有边两两不相交.

##### 相关定义

匹配边: 在某一匹配中的边.

匹配点: 某一匹配边的端点.

交错路: 匹配边和非匹配边相互交替的路径.

增广路: 起点和终点均为非匹配点的交错路.

取反: 将某一条交错路中的非匹配边变为匹配边, 匹配边变为非匹配边.

* 例如, 对于0->1->2->3->4->5这条路径, 如果有匹配<1,2><3,4>, 取反后变为<0,1><2,3><4,5>.

$cp$: 对于匹配边<$u$,$v$>, 有$cp(u)=v,cp(v)=u$.

##### 简略解释

显然, 将增广路中所有边取反后, 匹配边集会多1条边.

所以我们的目的是不断寻找增广路并将其取反. 可以证明这一定能得到最优方案.

增广过程中我们可能会遇到一个匹配完成的奇环, 我们称其为**花**.

方便起见, 我们将**花**缩成一个点.

我们分别尝试将每个点作为起点进行增广, 即可得到最大匹配.

##### 详细解释

我们枚举每个点, 如果**当前点$s$为非匹配点**, 则尝试以$s$为起点用bfs寻找增广路.

######寻找增广路: bfs(s)

我们记录每个点的type以寻找奇环. 每次bfs时清空之前记录的type. 用并查集记录缩点信息.

我们令起点$s$的type为1. 将$s$入队. **队列中只有type=1的点. $s$为非匹配点.**

我们记录所有type为2的点$x$在bfs树上的祖先$p(x)$.

类似普通bfs, 每次从队首取出一个顶点$u$. 我们考虑所有边<$u$,$v$>. 分以下几种情况.

* 如果$u$, $v$已经被缩成一个点, 或者$v$的type为2, 直接跳过$v$.
* 如果$v$的type为1, 则说明存在奇环$u$->$v$. 我们找到bfs树上$u$和$v$的$lca$, 它显然应该作为花的**根**. 我们将奇环$u$->$v$在并查集中的祖先改为$lca$. 这一过程称为**缩花**. 我们需要分别进行正反两次缩花: blossom(u,v)和blossom(v,u).
* 如果$v$还没有type, 我们将$v$的type设为2, $p(v)$设为$u$. 此时,
  * 如果$v$为匹配点, 设有匹配边<$v$,$w$>, 我们将$w$的type设为1, 将$w$入队.
  * 如果$v$为非匹配点, 显然有增广路$s$->$v$. 增广后结束bfs过程.

如果队列为空时仍未找到以$s$为起点的增广路, 则增广失败.

###### 查询花根: lca(u,v)

由bfs过程, 我们知道$u$和$v$的type都是1.

对于$u$点, 并查集中的$find(u)$即为$u$所在**花**的根. (初始时所有点都是花)

注意到在bfs树上, 所有匹配边从上往下都是从type=2的点到type=1的点.

于是若$v$的type是1, 我们可以通过$p(cp(v))$访问bfs树中$v$上方的最近一个type=1的点.

我们通过上述方法不断让$u$和$v$交替向上走, 走过的点打上标记, 如果走到了一个有标记的点$x$, 则$x$是$lca$.

######缩花: blossom(u,v)

令$root=lca(u,v)$. 这里$u$和$v$的type依然为1.

我们沿着$p(cp(u))$遍历整个奇环, 将并查集中的父亲结点均改为$root$.

由于此时整朵**花**被视为一个结点, 我们需要将整个**花**的所有结点的type改为1.

如果有结点的type由2变为1, 我们需要将其入队.

#####时间复杂度

算法的总时间复杂度为$O(n^3)$.

